[
  {
    "objectID": "logs/daily-logs.html",
    "href": "logs/daily-logs.html",
    "title": "Logbook",
    "section": "",
    "text": "Date: 25-08-30\n\nRevised chapter 1, and wrote detailed notes\nStarted writing notes for Forwardk kinematics notes\n\nDenavit‚ÄìHartenberg parameters took some time to understand, but in the end the realized that URDF to FK is probably more important.\n\n\n\n\nDate: 25-08-24\n\nRead through Chatper 1: Introduction to Robotics of ‚ÄúRobot Modelling and control‚Äù by Spong\nSpent a bunch of time figuring out the correct format to log notes to github.\nExperimented with Jekyll and Hugo, both of which sucked at rendering LaTex\nFinally after much experimentation Quarto seemed like a good option\nThis is a sample file using quarto‚Äôs math rendering link"
  },
  {
    "objectID": "entries/simple_robot.urdf.html",
    "href": "entries/simple_robot.urdf.html",
    "title": "Logbook",
    "section": "",
    "text": "&lt;sensor type=\"lidar\" name=\"lidar\"&gt;\n        &lt;always_on&gt;true&lt;/always_on&gt;\n        &lt;update_rate&gt;5&lt;/update_rate&gt;\n        &lt;origin&gt;0 0 0.2569669071788341 0 0 0&lt;/origin&gt;\n        &lt;ray&gt;\n            &lt;scan&gt;\n                &lt;horizontal&gt;\n                    &lt;samples&gt;360&lt;/samples&gt;\n                    &lt;resolution&gt;1&lt;/resolution&gt;\n                    &lt;min_angle&gt;0&lt;/min_angle&gt;\n                    &lt;max_angle&gt;6.28&lt;/max_angle&gt;\n                &lt;/horizontal&gt;\n                &lt;range&gt;\n                    &lt;min&gt;0.12&lt;/min&gt;\n                    &lt;max&gt;3.5&lt;/max&gt;\n                    &lt;resolution&gt;0.015&lt;/resolution&gt;\n                &lt;/range&gt;\n            &lt;/scan&gt;\n            &lt;noise&gt;\n                &lt;type&gt;gaussian&lt;/type&gt;\n                &lt;mean&gt;0&lt;/mean&gt;\n                &lt;stddev&gt;0.01&lt;/stddev&gt;\n            &lt;/noise&gt;\n        &lt;/ray&gt;\n    &lt;/sensor&gt;\n  &lt;/link&gt;\n                                                                                                            \n    &lt;sensor name=\"front_camera\" type=\"camera\"&gt;\n        &lt;always_on&gt;true&lt;/always_on&gt;\n        &lt;update_rate&gt;100&lt;/update_rate&gt;\n        &lt;origin&gt;1.6256258584357346 -0.02298885073006307 0.3695319117946291 0 0 0&lt;/origin&gt;\n        &lt;camera&gt;\n            &lt;horizontal_fov&gt;1.3962634&lt;/horizontal_fov&gt;\n            &lt;image&gt;\n                &lt;width&gt;800&lt;/width&gt;\n                &lt;height&gt;600&lt;/height&gt;\n                &lt;format&gt;R8G8B8&lt;/format&gt;\n            &lt;/image&gt;\n            &lt;clip&gt;\n                &lt;near&gt;0.1&lt;/near&gt;\n                &lt;far&gt;100&lt;/far&gt;\n            &lt;/clip&gt;\n            &lt;noise&gt;\n                &lt;type&gt;gaussian&lt;/type&gt;\n                &lt;mean&gt;0.01&lt;/mean&gt;\n            &lt;/noise&gt;\n        &lt;/camera&gt;\n    &lt;/sensor&gt;\n  &lt;/link&gt;\n                         \n    &lt;sensor type=\"imu\" name=\"imu\"&gt;\n        &lt;always_on&gt;true&lt;/always_on&gt;\n        &lt;update_rate&gt;100&lt;/update_rate&gt;\n        &lt;origin&gt;-1.1282184172017464 0.06064584319013511 0.17904669409114127 0 0 0&lt;/origin&gt;\n        &lt;imu&gt;\n            &lt;noise&gt;\n                &lt;type&gt;gaussian&lt;/type&gt;\n                &lt;mean&gt;0&lt;/mean&gt;\n                &lt;stddev&gt;0&lt;/stddev&gt;\n            &lt;/noise&gt;\n        &lt;/imu&gt;\n    &lt;/sensor&gt;\n  &lt;/link&gt;"
  },
  {
    "objectID": "entries/forward_kinematics.html",
    "href": "entries/forward_kinematics.html",
    "title": "Forward kinematics for Robot Manipulators",
    "section": "",
    "text": "What is kinematics / forward kinematics ?\nHow to derive forward kinematics from URDF of any arbitrary robot ?\nWhat are DH-parameters and why do we use them ?\nHow to practically do forward kinematics for arbitrary robot kinematic chains\nWhat libraries exist out there ?"
  },
  {
    "objectID": "entries/forward_kinematics.html#what-are-the-available-tools-to-obtain-fk-from-urdf",
    "href": "entries/forward_kinematics.html#what-are-the-available-tools-to-obtain-fk-from-urdf",
    "title": "Forward kinematics for Robot Manipulators",
    "section": "What are the available tools to obtain FK from URDF ?",
    "text": "What are the available tools to obtain FK from URDF ?\nLets see what exists out there and then we start digging in: (Asked Google‚Äôs Gemini)\n\n\n\n\n\n\nNote\n\n\n\nThis list is not exhaustive, but should expose us to a plenty of things that exists out there. and ultimately make our learning experience better.\n\n\n\nPython Libraries\n\npinnochio (Written in C++, has python bindings)\npytorch-kinematics\nurdfpy\nurdf2casadi [Winner üéâ]\n\n\n\nC++ Libraries\n\nKinematics and Dynamics Library (KDL)\nMoveIt\npinnochio\n\nFor details on usability trade‚Äëoffs and Python APIs for forward kinematics, see: FK in python We will revisit performance trade-offs some other time, and thus also ignoring the C++ libraries"
  },
  {
    "objectID": "entries/chapter_1_spong_notes.html",
    "href": "entries/chapter_1_spong_notes.html",
    "title": "Chapter 1: Robot Modeling and Control (spong)",
    "section": "",
    "text": "The very first robots (or so called non-servo robots) didn‚Äôt have any feedback in place. They were basically issued sequence of commands, .e.g. Move to point A, Close gripper, Move to point B, usually with hard mechanical stops or limit switches but there wasn‚Äôt any real feedback"
  },
  {
    "objectID": "entries/chapter_1_spong_notes.html#history",
    "href": "entries/chapter_1_spong_notes.html#history",
    "title": "Chapter 1: Robot Modeling and Control (spong)",
    "section": "",
    "text": "The very first robots (or so called non-servo robots) didn‚Äôt have any feedback in place. They were basically issued sequence of commands, .e.g. Move to point A, Close gripper, Move to point B, usually with hard mechanical stops or limit switches but there wasn‚Äôt any real feedback"
  },
  {
    "objectID": "entries/chapter_1_spong_notes.html#components-and-structure-of-robots",
    "href": "entries/chapter_1_spong_notes.html#components-and-structure-of-robots",
    "title": "Chapter 1: Robot Modeling and Control (spong)",
    "section": "1.2 Components and Structure of robots",
    "text": "1.2 Components and Structure of robots\n\n1.2.1 Symbolic representation of robots\nBasically robots are kinematic chains, which are made up of links and joints. These joints can be revolute (R), or prismatic (P). The axis of rotation, or axis of translation is denoted by z\n\n\n1.2.2 Degrees of freedom and workspace\nDegrees of freedom\nSo actually, when we talk about degrees of freedom for a kinematic mechanism, (think four bar linkage) the degrees of freedom doesn‚Äôt directly equate to the number of joints, and is given by the Gruebler‚Äôs formula,\n\\[\nF = 3 (n - 1) - 2L - H\n\\]\nwhere:\n\n\\(F\\) = number of degrees of freedom\n\n\\(n\\) = total number of links including the fixed base\n\n\\(L\\) = total number of lower pairs (1 DOF such as pins and sliding joints)\n\n\\(H\\) = total number of higher pairs (2 DOF such as cam and gear joints)\n\nYou can refer here for more details: source\nHaving said that, for a lot of the industrial manipulators, they are designed in a way that the joints are mostly independent of each other and thus number of degrees of freedom == number of joints. For a robot to reach 3D space with arbitrary orientation, it must have atleast 6DOFs i.e.¬†3 for position and 3 for orientation. If a robot has more than 6 DOF, then its called a kinematically redundant chain ‚Äì which is especially useful if we have to avoid obstacles.\nWorkspace\nOkay, with that out of the way, lets talk of workspace. So by definition, its the total volume swept by the end effector as it executes all possible motions. The shape of this volume depends on the robot geometry and the limits on the joints (for example a revolute joint might have less than 360 degree rotation). Its often broken down into 1. reachable workspace ‚Äì&gt; Entire set of points we can physically reach 2. dextorous workspace ‚Äì&gt; Subset of the workspace, where we can reach with arbitrary orientation\n\n\n1.2.3 Classification of robots\n\n\n\n\n\nflowchart LR\n    B[Power Source]\n    B --&gt; B1[Hydraulics\\n e.g. Atlas]\n    B --&gt; B2[Electrical\\n e.g. UR]\n    B --&gt; B3[Pnuematics] --- B3N[[Note: Air is compressible\\nso not very precise,\\n hence not popular]]\n\n\n\n\n\n\n\n\n\n\n\n\nflowchart LR\n    C[Application area]\n\n    C --&gt; C1[Assembly]\n    C --&gt; C2[Non-Assembly]\n\n\n\n\n\n\n\n\n\n\n\n\nflowchart LR\n    D[Method of control]\n\n    D --&gt; D1[Servo]\n    D --&gt; D2[Non-Servo]\n\n\n\n\n\n\n\n\n\n\n\n\nflowchart LR\n    E[Geometry]\n\n    E --&gt; E1[Articulate RRR]\n    E --&gt; E2[spherical RRP]\n    E --&gt; E3[SCARA RRP]\n    E --&gt; E4[Cylindrical RPP]\n    E --&gt; E5[Cartesian PPP]\n\n\n\n\n\n\n\n\n1.2.4 Common Kinematic Arrangements\n\nArticulated RRR\nElbow configuration\n\n \n\nParallelogram configuration\n\n\n\nSpherical RRP\n\n\n\nSCARA RRP\n\n\n\nCylindrical RPP\n\n\n\nCartesian PPP\n\n\n\n\n1.2.4 Wrist and End effectors\nSo far we have discussed the different kinematic configurations of a robot, and what they are typically describing is a Robot ARM. For the robot to do anything meaningful we need an end effector / hand / EoAT (end of arm tooling). Typically these EoATs are grippers, but also can be more complex depending on the need of the task. So a wrist then is anything that comes between the ARM and the EoAT\nOne interesting thing to note is that:\n\nThe ARM is usally responsible for the positional degrees of freedom\nThe WRIST typically deals with the orientational degrees of freedom\n\nWrists are also typically spherical, by that I mean, the roll/pitch/yaw axes all intersect at the same point. Here‚Äôs a synbolic representation of a wrist"
  },
  {
    "objectID": "scripts/fk_using_urdf2casadi.html",
    "href": "scripts/fk_using_urdf2casadi.html",
    "title": "Logbook",
    "section": "",
    "text": "import casadi as cs\nfrom urdf2casadi import urdfparser as u2c\nimport numpy as np\n\nurdf_path = \"sample.urdf\"\nrobot_parser = u2c.URDFparser()\nrobot_parser.from_file(urdf_path)\n\n# We can control which subchain we want from here\nroot=\"root\"\ntip=\"r_wrist2\"\n\nfk_dict = robot_parser.get_forward_kinematics(root, tip)\nfk = fk_dict[\"T_fk\"]\n\nprint(fk)\n# should print: T_fk:(i0[6])-&gt;(o0[4x4]) SXFunction\n# which means input is 6 vector, and output is a 4x4 matrix\nq = np.zeros(6)\nfk(q)\n\"\"\"\nDM(\n[[1, 0, 0, 0], \n [0, 1, 0, -0.4], \n [0, 0, 1, -0.4], \n [0, 0, 0, 1]])\n\"\"\"\n\nT_fk:(i0[6])-&gt;(o0[4x4]) SXFunction\n\n\n'\\nDM(\\n[[1, 0, 0, 0], \\n [0, 1, 0, -0.4], \\n [0, 0, 1, -0.4], \\n [0, 0, 0, 1]])\\n'"
  },
  {
    "objectID": "scripts/fk_using_pytorch_kinematics.html",
    "href": "scripts/fk_using_pytorch_kinematics.html",
    "title": "Logbook",
    "section": "",
    "text": "import pytorch_kinematics as pk\nimport math\nimport torch\n\n\n# Loading robots\nurdf = \"sample.urdf\"\nchain = pk.build_chain_from_urdf(open(urdf, mode=\"rb\").read())\n\nchain.print_tree()\n\"\"\"\nroot\n‚îú‚îÄ‚îÄ l_shoulder1\n‚îÇ   ‚îî‚îÄ‚îÄ l_shoulder2\n‚îÇ       ‚îî‚îÄ‚îÄ l_shoulder3\n‚îÇ           ‚îî‚îÄ‚îÄ l_elbow1\n‚îÇ               ‚îî‚îÄ‚îÄ l_wrist1\n‚îÇ                   ‚îî‚îÄ‚îÄ l_wrist2\n‚îî‚îÄ‚îÄ r_shoulder1\n    ‚îî‚îÄ‚îÄ r_shoulder2\n        ‚îî‚îÄ‚îÄ r_shoulder3\n            ‚îî‚îÄ‚îÄ r_elbow1\n                ‚îî‚îÄ‚îÄ r_wrist1\n                    ‚îî‚îÄ‚îÄ r_wrist2\n\"\"\"\n\n## FK\n\n# Extract a sepcifical searial chain\nserial_chain = pk.SerialChain(chain, \"l_wrist2\", \"l_elbow1\")\nserial_chain.print_tree()\n\"\"\"\nl_elbow1\n‚îî‚îÄ‚îÄ l_wrist1\n    ‚îî‚îÄ‚îÄ l_wrist2\n\"\"\"\n# Generate random joint variables\nbatch_size=1\nq_random = torch.rand(batch_size, len(chain.get_joint_parameter_names()))\nprint(q_random)\n\nret = chain.forward_kinematics(q_random)\nprint(ret) # Contains transformation rot, pos\n\n\n# Print a specific joint\ntransform = ret['l_shoulder1'] # From the base, since that was the chain\n# Get it as a matrix\nm = transform.get_matrix()\n# Extract position and rotation\npos = m[:,:3, 3]\n# Extract quaternion\nrot = pk.matrix_to_quaternion(m[:, :3, :3])"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "A place for documenting my robotics/software learning journey. Hop along!"
  },
  {
    "objectID": "scripts/fk_using_pinnochio.html",
    "href": "scripts/fk_using_pinnochio.html",
    "title": "Logbook",
    "section": "",
    "text": "import pinocchio as pin\nimport os\n\n# Load model from urdf\nurdf_path = \"sample.urdf\"\nmodel = pin.buildModelFromUrdf(urdf_path)\ndata = model.createData()\n\n# Define a random robot configuration\nq = pin.randomConfiguration(model)\nprint(\"Random configuration q:\\n\", q.T)\n\n# Compute forward kinemeatics for all frames\npin.framesForwardKinematics(model, data, q)\n\n# Access the end-effector placement\nee_frame_name = model.frames[-1].name\nframe_id = model.getFrameId(ee_frame_name)\nee_fk = data.oMf[frame_id]\n\nprint(\"ee SE(3):\\n\", ee_fk)\nprint(\"ee translation:\\n\", ee_fk.translation)\nprint(\"ee rotation SO(3):\\n\", ee_fk.rotation)\n\n# Access and print all joint positions\nfor joint_id, joint_name in enumerate(model.names):\n    position = data.oMi[joint_id].translation\n    rotation  = data.oMi[joint_id].rotation\n    print(f\"joint_name:\\n {joint_name}, position:\\n {position.T}, rotation:\\n {rotation}\")\n\nRandom configuration q:\n [ 0.82605335  0.63939031 -0.92271389 -0.34254493 -0.26171002 -0.64227246\n  0.37477487 -0.80071987 -0.40757604  0.2718815  -1.08711455  0.97668538]\nee SE(3):\n   R =\n 0.711998  0.699638 0.0597093\n-0.578598  0.632741 -0.514648\n-0.397848  0.331881   0.85532\n  p =  0.447523 -0.488188 -0.251216\n\nee translation:\n [ 0.44752321 -0.48818838 -0.25121612]\nee rotation SO(3):\n [[ 0.71199815  0.69963807  0.05970935]\n [-0.578598    0.63274144 -0.51464805]\n [-0.39784795  0.33188075  0.85531993]]\njoint_name:\n universe, position:\n [0. 0. 0.], rotation:\n [[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\njoint_name:\n l_shoulder_yaw, position:\n [0.  0.2 0.2], rotation:\n [[ 0.67778285 -0.73526214  0.        ]\n [ 0.73526214  0.67778285  0.        ]\n [ 0.          0.          1.        ]]\njoint_name:\n l_shoulder_pitch, position:\n [-0.07352621  0.26777828  0.2       ], rotation:\n [[ 0.54389343 -0.73526214  0.40443729]\n [ 0.59001824  0.67778285  0.43873555]\n [-0.5967063   0.          0.80245972]]\njoint_name:\n l_shoulder_roll, position:\n [-0.14705243  0.33555657  0.2       ], rotation:\n [[ 0.54389343 -0.76628215 -0.34204035]\n [ 0.59001824  0.05937078  0.80520406]\n [-0.5967063  -0.63975525  0.48441183]]\njoint_name:\n l_elbow_pitch, position:\n [-0.07864436  0.17451576  0.10311763], rotation:\n [[ 0.3974085  -0.76628215 -0.50485458]\n [ 0.82619608  0.05937078  0.56024562]\n [-0.39933261 -0.63975525  0.65669376]]\njoint_name:\n l_wrist_yaw, position:\n [ 0.02232656  0.06246663 -0.02822112], rotation:\n [[ 0.58213859 -0.63736686 -0.50485458]\n [ 0.78270207  0.2711131   0.56024562]\n [-0.2202093  -0.72129132  0.65669376]]\njoint_name:\n l_wrist_pitch, position:\n [ 0.12329748 -0.04958249 -0.15955987], rotation:\n [[ 0.16372337 -0.63736686 -0.75296623]\n [ 0.96233463  0.2711131  -0.02024239]\n [ 0.21704084 -0.72129132  0.65774775]]\njoint_name:\n r_shoulder_yaw, position:\n [ 0.  -0.2  0.2], rotation:\n [[ 0.93059006 -0.36606303  0.        ]\n [ 0.36606303  0.93059006  0.        ]\n [ 0.          0.          1.        ]]\njoint_name:\n r_shoulder_pitch, position:\n [ 0.0366063  -0.29305901  0.2       ], rotation:\n [[ 0.64786761 -0.36606303 -0.668031  ]\n [ 0.25484947  0.93059006 -0.26278107]\n [ 0.71785745  0.          0.69619012]]\njoint_name:\n r_shoulder_roll, position:\n [ 0.07321261 -0.38611801  0.2       ], rotation:\n [[ 0.64786761 -0.07127921 -0.75841073]\n [ 0.25484947  0.95852266  0.12761684]\n [ 0.71785745 -0.27595939  0.63916125]]\njoint_name:\n r_elbow_pitch, position:\n [ 0.22489475 -0.41164138  0.07216775], rotation:\n [[ 0.82773658 -0.07127921 -0.55657113]\n [ 0.2112174   0.95852266  0.1913675 ]\n [ 0.51984552 -0.27595939  0.80845968]]\njoint_name:\n r_wrist_yaw, position:\n [ 0.33620898 -0.44991488 -0.08952419], rotation:\n [[ 0.44803475  0.69963807 -0.55657113]\n [-0.75034442  0.63274144  0.1913675 ]\n [ 0.48605361  0.33188075  0.80845968]]\njoint_name:\n r_wrist_pitch, position:\n [ 0.44752321 -0.48818838 -0.25121612], rotation:\n [[ 0.71199815  0.69963807  0.05970935]\n [-0.578598    0.63274144 -0.51464805]\n [-0.39784795  0.33188075  0.85531993]]"
  },
  {
    "objectID": "scripts/fk_using_urdfpy.html",
    "href": "scripts/fk_using_urdfpy.html",
    "title": "Logbook",
    "section": "",
    "text": "from urdfpy import URDF\nimport os\n\nos.environ[\"PYOPENGL_PLATFORM\"] = \"egl\"  # or \"osmesa\" for CPU-only\n\nurdf_file = \"sample.urdf\"\nrobot = URDF.load(urdf_file)\n\n# Print links\nfor link in robot.links:\n    # print(link.name)\n    pass\n\n# Print joints\nfor joint in robot.joints:\n    # print(joint.name)\n    pass\n\n# Access actuated joints (ignoring the fixed joints)\nfor joint in robot.actuated_joints:\n    print(joint.name)\n    pass\n\n# Doing forward kinematics\nfk = robot.link_fk()\nfk[robot.links[2]]\nprint(fk)\n\nl_shoulder_yaw\nr_shoulder_yaw\nl_shoulder_pitch\nr_shoulder_pitch\nl_shoulder_roll\nr_shoulder_roll\nl_elbow_pitch\nr_elbow_pitch\nl_wrist_yaw\nr_wrist_yaw\nl_wrist_pitch\nr_wrist_pitch\nOrderedDict([(&lt;urdfpy.urdf.Link object at 0x721460524e50&gt;, array([[1., 0., 0., 0.],\n       [0., 1., 0., 0.],\n       [0., 0., 1., 0.],\n       [0., 0., 0., 1.]])), (&lt;urdfpy.urdf.Link object at 0x7214604cd160&gt;, array([[ 1. ,  0. ,  0. ,  0. ],\n       [ 0. ,  1. ,  0. , -0.2],\n       [ 0. ,  0. ,  1. ,  0.2],\n       [ 0. ,  0. ,  0. ,  1. ]])), (&lt;urdfpy.urdf.Link object at 0x721460524df0&gt;, array([[1. , 0. , 0. , 0. ],\n       [0. , 1. , 0. , 0.2],\n       [0. , 0. , 1. , 0.2],\n       [0. , 0. , 0. , 1. ]])), (&lt;urdfpy.urdf.Link object at 0x7214604cd8b0&gt;, array([[ 1. ,  0. ,  0. ,  0. ],\n       [ 0. ,  1. ,  0. , -0.3],\n       [ 0. ,  0. ,  1. ,  0.2],\n       [ 0. ,  0. ,  0. ,  1. ]])), (&lt;urdfpy.urdf.Link object at 0x721514270160&gt;, array([[1. , 0. , 0. , 0. ],\n       [0. , 1. , 0. , 0.3],\n       [0. , 0. , 1. , 0.2],\n       [0. , 0. , 0. , 1. ]])), (&lt;urdfpy.urdf.Link object at 0x7214604cd400&gt;, array([[ 1. ,  0. ,  0. ,  0. ],\n       [ 0. ,  1. ,  0. , -0.4],\n       [ 0. ,  0. ,  1. ,  0.2],\n       [ 0. ,  0. ,  0. ,  1. ]])), (&lt;urdfpy.urdf.Link object at 0x7215142843d0&gt;, array([[1. , 0. , 0. , 0. ],\n       [0. , 1. , 0. , 0.4],\n       [0. , 0. , 1. , 0.2],\n       [0. , 0. , 0. , 1. ]])), (&lt;urdfpy.urdf.Link object at 0x7214604cda60&gt;, array([[ 1. ,  0. ,  0. ,  0. ],\n       [ 0. ,  1. ,  0. , -0.4],\n       [ 0. ,  0. ,  1. ,  0. ],\n       [ 0. ,  0. ,  0. ,  1. ]])), (&lt;urdfpy.urdf.Link object at 0x721514284c70&gt;, array([[1. , 0. , 0. , 0. ],\n       [0. , 1. , 0. , 0.4],\n       [0. , 0. , 1. , 0. ],\n       [0. , 0. , 0. , 1. ]])), (&lt;urdfpy.urdf.Link object at 0x7214604cd430&gt;, array([[ 1. ,  0. ,  0. ,  0. ],\n       [ 0. ,  1. ,  0. , -0.4],\n       [ 0. ,  0. ,  1. , -0.2],\n       [ 0. ,  0. ,  0. ,  1. ]])), (&lt;urdfpy.urdf.Link object at 0x7214604cd7c0&gt;, array([[ 1. ,  0. ,  0. ,  0. ],\n       [ 0. ,  1. ,  0. ,  0.4],\n       [ 0. ,  0. ,  1. , -0.2],\n       [ 0. ,  0. ,  0. ,  1. ]])), (&lt;urdfpy.urdf.Link object at 0x7214604e3490&gt;, array([[ 1. ,  0. ,  0. ,  0. ],\n       [ 0. ,  1. ,  0. , -0.4],\n       [ 0. ,  0. ,  1. , -0.4],\n       [ 0. ,  0. ,  0. ,  1. ]])), (&lt;urdfpy.urdf.Link object at 0x7214604cdfd0&gt;, array([[ 1. ,  0. ,  0. ,  0. ],\n       [ 0. ,  1. ,  0. ,  0.4],\n       [ 0. ,  0. ,  1. , -0.4],\n       [ 0. ,  0. ,  0. ,  1. ]]))])"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Logbook",
    "section": "",
    "text": "Daily logs\nChapter 1: Robot Modelling and Control by Spong, notes\nConda basics\nForward kinematics\n\nForward Kinematics\nFK in python"
  },
  {
    "objectID": "index.html#contents",
    "href": "index.html#contents",
    "title": "Logbook",
    "section": "",
    "text": "Daily logs\nChapter 1: Robot Modelling and Control by Spong, notes\nConda basics\nForward kinematics\n\nForward Kinematics\nFK in python"
  },
  {
    "objectID": "entries/fk_in_python.html",
    "href": "entries/fk_in_python.html",
    "title": "Forward kinematics from URDF in python",
    "section": "",
    "text": "Parent document: Forward kinematics"
  },
  {
    "objectID": "entries/fk_in_python.html#installation",
    "href": "entries/fk_in_python.html#installation",
    "title": "Forward kinematics from URDF in python",
    "section": "Installation",
    "text": "Installation\n$ conda create -n urdfpy_env python=3.9\n$ conda activate urdfpy_env\n$ conda install -c conda-forge ipykernel urdfpy\n$ conda install numpy=1.26 # Downgrade numpy if you want to visualize"
  },
  {
    "objectID": "entries/fk_in_python.html#code-snippet",
    "href": "entries/fk_in_python.html#code-snippet",
    "title": "Forward kinematics from URDF in python",
    "section": "Code snippet",
    "text": "Code snippet\nThis is the cleanest interface i have seen so far!\n\nfrom urdfpy import URDF\nimport os\n\nos.environ[\"PYOPENGL_PLATFORM\"] = \"egl\"  # or \"osmesa\" for CPU-only\n\nurdf_file = \"sample.urdf\"\nrobot = URDF.load(urdf_file)\n\n# Print links\nfor link in robot.links:\n    # print(link.name)\n    pass\n\n# Print joints\nfor joint in robot.joints:\n    # print(joint.name)\n    pass\n\n# Access actuated joints (ignoring the fixed joints)\nfor joint in robot.actuated_joints:\n    print(joint.name)\n    pass\n\n# Doing forward kinematics\nfk = robot.link_fk()\nfk[robot.links[2]]\nprint(fk)"
  },
  {
    "objectID": "entries/fk_in_python.html#installation-1",
    "href": "entries/fk_in_python.html#installation-1",
    "title": "Forward kinematics from URDF in python",
    "section": "Installation",
    "text": "Installation\n$ conda create -n urdf2casadi_env python=3.9\n$ conda activate urdf2casadi_env\n$ conda install -c conda-forge ipykernel urdf2casadi"
  },
  {
    "objectID": "entries/fk_in_python.html#code-snippet-1",
    "href": "entries/fk_in_python.html#code-snippet-1",
    "title": "Forward kinematics from URDF in python",
    "section": "Code snippet",
    "text": "Code snippet\n\nimport casadi as cs\nfrom urdf2casadi import urdfparser as u2c\nimport numpy as np\n\nurdf_path = \"sample.urdf\"\nrobot_parser = u2c.URDFparser()\nrobot_parser.from_file(urdf_path)\n\n# We can control which subchain we want from here\nroot=\"root\"\ntip=\"r_wrist2\"\n\nfk_dict = robot_parser.get_forward_kinematics(root, tip)\nfk = fk_dict[\"T_fk\"]\n\nprint(fk)\n# should print: T_fk:(i0[6])-&gt;(o0[4x4]) SXFunction\n# which means input is 6 vector, and output is a 4x4 matrix\nq = np.zeros(6)\nfk(q)\n\"\"\"\nDM(\n[[1, 0, 0, 0], \n [0, 1, 0, -0.4], \n [0, 0, 1, -0.4], \n [0, 0, 0, 1]])\n\"\"\""
  },
  {
    "objectID": "entries/fk_in_python.html#installation-2",
    "href": "entries/fk_in_python.html#installation-2",
    "title": "Forward kinematics from URDF in python",
    "section": "Installation",
    "text": "Installation\n# Doing it in conda saves so much headache later on, since\n# pinnochio for e.g. only works in python=3.9\n\n$ conda create -n pytorch_kin_env python=3.11\n$ conda activate pytorch_kin_env\n$ conda install -c conda-forge ipykernel\n$ pip install pytorch_kinematics"
  },
  {
    "objectID": "entries/fk_in_python.html#code-snippet-2",
    "href": "entries/fk_in_python.html#code-snippet-2",
    "title": "Forward kinematics from URDF in python",
    "section": "Code snippet",
    "text": "Code snippet\n\nimport pytorch_kinematics as pk\nimport math\nimport torch\n\n\n# Loading robots\nurdf = \"sample.urdf\"\nchain = pk.build_chain_from_urdf(open(urdf, mode=\"rb\").read())\n\nchain.print_tree()\n\"\"\"\nroot\n‚îú‚îÄ‚îÄ l_shoulder1\n‚îÇ   ‚îî‚îÄ‚îÄ l_shoulder2\n‚îÇ       ‚îî‚îÄ‚îÄ l_shoulder3\n‚îÇ           ‚îî‚îÄ‚îÄ l_elbow1\n‚îÇ               ‚îî‚îÄ‚îÄ l_wrist1\n‚îÇ                   ‚îî‚îÄ‚îÄ l_wrist2\n‚îî‚îÄ‚îÄ r_shoulder1\n    ‚îî‚îÄ‚îÄ r_shoulder2\n        ‚îî‚îÄ‚îÄ r_shoulder3\n            ‚îî‚îÄ‚îÄ r_elbow1\n                ‚îî‚îÄ‚îÄ r_wrist1\n                    ‚îî‚îÄ‚îÄ r_wrist2\n\"\"\"\n\n## FK\n\n# Extract a sepcifical searial chain\nserial_chain = pk.SerialChain(chain, \"l_wrist2\", \"l_elbow1\")\nserial_chain.print_tree()\n\"\"\"\nl_elbow1\n‚îî‚îÄ‚îÄ l_wrist1\n    ‚îî‚îÄ‚îÄ l_wrist2\n\"\"\"\n# Generate random joint variables\nbatch_size=1\nq_random = torch.rand(batch_size, len(chain.get_joint_parameter_names()))\nprint(q_random)\n\nret = chain.forward_kinematics(q_random)\nprint(ret) # Contains transformation rot, pos\n\n\n# Print a specific joint\ntransform = ret['l_shoulder1'] # From the base, since that was the chain\n# Get it as a matrix\nm = transform.get_matrix()\n# Extract position and rotation\npos = m[:,:3, 3]\n# Extract quaternion\nrot = pk.matrix_to_quaternion(m[:, :3, :3])"
  },
  {
    "objectID": "entries/fk_in_python.html#installation-3",
    "href": "entries/fk_in_python.html#installation-3",
    "title": "Forward kinematics from URDF in python",
    "section": "Installation",
    "text": "Installation\n$ conda create -n pin_env python=3.9 # Note 3.9 is very important here\n$ conda activate pin_env\n$ conda install -c conda-forge ipykernel pinocchio"
  },
  {
    "objectID": "entries/fk_in_python.html#code-snippet-3",
    "href": "entries/fk_in_python.html#code-snippet-3",
    "title": "Forward kinematics from URDF in python",
    "section": "Code snippet",
    "text": "Code snippet\n\nimport pinocchio as pin\nimport os\n\n# Load model from urdf\nurdf_path = \"sample.urdf\"\nmodel = pin.buildModelFromUrdf(urdf_path)\ndata = model.createData()\n\n# Define a random robot configuration\nq = pin.randomConfiguration(model)\nprint(\"Random configuration q:\\n\", q.T)\n\n# Compute forward kinemeatics for all frames\npin.framesForwardKinematics(model, data, q)\n\n# Access the end-effector placement\nee_frame_name = model.frames[-1].name\nframe_id = model.getFrameId(ee_frame_name)\nee_fk = data.oMf[frame_id]\n\nprint(\"ee SE(3):\\n\", ee_fk)\nprint(\"ee translation:\\n\", ee_fk.translation)\nprint(\"ee rotation SO(3):\\n\", ee_fk.rotation)\n\n# Access and print all joint positions\nfor joint_id, joint_name in enumerate(model.names):\n    position = data.oMi[joint_id].translation\n    rotation  = data.oMi[joint_id].rotation\n    print(f\"joint_name:\\n {joint_name}, position:\\n {position.T}, rotation:\\n {rotation}\")"
  },
  {
    "objectID": "entries/conda_basics.html",
    "href": "entries/conda_basics.html",
    "title": "Conda basics",
    "section": "",
    "text": "// Creating a conda environment\n$ conda create -n myenv python=3.9 # whatever python version\n\n// List environment\n$ conda list env\n\n# conda environments:\n#\nbase                   /home/kartik/anaconda3\nmyenv                * /home/kartik/anaconda3/envs/myenv\npinnochio_env          /home/kartik/anaconda3/envs/pinnochio_env\n\n// Deactivating environments\n$ conda deactivate\n\n// Removing environments\n$ conda remove -n myenv --all\n\n// Installing a package, we will try and install the following packages:\n// pinnochio, notebook, ipykernel, hpp-fcl\n$ conda install -c conda-forge pinochio notebook ipykernel hpp-fcl\n\n// Register ipykernel inside the environment so that we can find it \n// inside notebooks in vscode\n$ python -m ipykernel install --user --name=pinocchio_env --display-name 'Python pinocchio_dev'\n\n//"
  },
  {
    "objectID": "test/math.html",
    "href": "test/math.html",
    "title": "Math Notes",
    "section": "",
    "text": "The derivative of a function (f(x)) is defined as:\n\\[\nf'(x) = \\lim_{h \\to 0} \\frac{f(x+h) - f(x)}{h}\n\\]\nExample in Python using Sympy:\n\nimport sympy as sp\nfrom sympy import init_printing\n\ninit_printing()  # pretty LaTeX-style output in HTML\n\nx = sp.symbols('x')\nf = x**2 + 3*x + 2\n\n# Compute derivative\nsp.diff(f, x)"
  },
  {
    "objectID": "test/math.html#derivatives",
    "href": "test/math.html#derivatives",
    "title": "Math Notes",
    "section": "",
    "text": "The derivative of a function (f(x)) is defined as:\n\\[\nf'(x) = \\lim_{h \\to 0} \\frac{f(x+h) - f(x)}{h}\n\\]\nExample in Python using Sympy:\n\nimport sympy as sp\nfrom sympy import init_printing\n\ninit_printing()  # pretty LaTeX-style output in HTML\n\nx = sp.symbols('x')\nf = x**2 + 3*x + 2\n\n# Compute derivative\nsp.diff(f, x)"
  }
]